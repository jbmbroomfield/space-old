{"ast":null,"code":"import Path from './Path';\n\nfunction mult(number, point) {\n  return [number * point[0], number * point[1]];\n}\n\nfunction add(point1, point2) {\n  return [point1[0] + point2[0], point1[1] + point2[1]];\n}\n\nfunction neg(point) {\n  return mult(-1, point);\n}\n\nfunction subtract(point1, point2) {\n  return add(point1, neg(point2));\n}\n\nfunction getPosition(p0, p1, t) {\n  const term1 = mult(1 - t, p0);\n  const term2 = mult(t, p1);\n  return add(term1, term2);\n}\n\nclass Bezier extends Path {\n  constructor(startTime, endTime, ...points) {\n    super();\n    this.startTime = startTime;\n    this.endTime = endTime;\n\n    if (points.length === 1) {\n      this.initial = points[0];\n      this.final = points[0];\n    } else {\n      this.initial = new Bezier(startTime, endTime, ...points.slice(0, points.length - 1));\n      this.final = new Bezier(startTime, endTime, ...points.slice(1, points.length));\n    }\n  }\n\n  position(time) {\n    if (time < this.startTime) {\n      time = this.startTime;\n    }\n\n    if (time > this.endTime) {\n      time = this.endTime;\n    }\n\n    const t = (time - this.startTime) / (this.endTime - this.startTime);\n    return this.position_by_t(t);\n  }\n\n  position_by_t(t) {\n    if (this.initial === this.final) {\n      return this.initial;\n    }\n\n    const p0 = this.initial.position_by_t(t);\n    const p1 = this.final.position_by_t(t);\n    return getPosition(p0, p1, t);\n  }\n\n  get initialVelocity() {\n    return this.velocity(this.startTime);\n  }\n\n  get initialSpeed() {\n    return this.speed(this.startTime);\n  }\n\n  get finalVelocity() {\n    return this.velocity(this.endTime);\n  }\n\n  get finalSpeed() {\n    return this.speed(this.endTime - 1);\n  }\n\n  get maxSpeed() {\n    let return_value = 0;\n\n    for (let time = this.startTime; time <= this.endTime; time++) {\n      return_value = Math.max(return_value, this.speed(time));\n    }\n\n    return return_value;\n  }\n\n  static newLinearFromEndTime(entity, destination, startTime, endTime) {\n    const p0 = [...entity.position(startTime)];\n    const p1 = [...destination.position(endTime)];\n    return new this(startTime, endTime, p0, p1);\n  }\n\n  static newQuadraticFromEndTime(entity, destination, startTime, endTime) {\n    const p0 = entity.position(startTime);\n    const p2 = destination.position(endTime);\n    const initialV = [...entity.velocity]; // const p1 = \n  }\n\n}\n\nexport default Bezier;","map":{"version":3,"sources":["/home/jim/projects/space/src/classes/Bezier.js"],"names":["Path","mult","number","point","add","point1","point2","neg","subtract","getPosition","p0","p1","t","term1","term2","Bezier","constructor","startTime","endTime","points","length","initial","final","slice","position","time","position_by_t","initialVelocity","velocity","initialSpeed","speed","finalVelocity","finalSpeed","maxSpeed","return_value","Math","max","newLinearFromEndTime","entity","destination","newQuadraticFromEndTime","p2","initialV"],"mappings":"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","sourcesContent":["import Path from './Path'\n\nfunction mult(number, point) {\n    return [number * point[0], number * point[1]]\n}\n\nfunction add(point1, point2) {\n    return [point1[0] + point2[0], point1[1] + point2[1]]\n}\n\nfunction neg(point) {\n    return mult(-1, point)\n}\n\nfunction subtract(point1, point2) {\n    return add(point1, neg(point2))\n}\n\nfunction getPosition(p0, p1, t) {\n    const term1 = mult(1 - t, p0)\n    const term2 = mult(t, p1)\n    return add(term1, term2)\n}\n\nclass Bezier extends Path {\n\n    constructor(startTime, endTime, ...points) {\n        super()\n        this.startTime = startTime\n        this.endTime = endTime\n        if (points.length === 1) {\n            this.initial = points[0]\n            this.final = points[0]\n        } else {\n            this.initial = new Bezier(startTime, endTime, ...points.slice(0, points.length - 1))\n            this.final = new Bezier(startTime, endTime, ...points.slice(1, points.length))\n        }\n    }\n\n    position(time) {\n        if (time < this.startTime) {\n            time = this.startTime\n        }\n        if (time > this.endTime) {\n            time = this.endTime\n        }\n        const t = (time - this.startTime) / (this.endTime - this.startTime)\n        return this.position_by_t(t)\n    }\n\n    position_by_t(t) {\n        if (this.initial === this.final) {\n            return this.initial\n        }\n        const p0 = this.initial.position_by_t(t)\n        const p1 = this.final.position_by_t(t)\n        return getPosition(p0, p1, t)\n    }\n\n    get initialVelocity() {\n        return this.velocity(this.startTime)\n    }\n\n    get initialSpeed() {\n        return this.speed(this.startTime)\n    }\n\n    get finalVelocity() {\n        return this.velocity(this.endTime)\n    }\n\n    get finalSpeed() {\n        return this.speed(this.endTime - 1)\n    }\n\n    get maxSpeed() {\n        let return_value = 0\n        for (let time = this.startTime; time <= this.endTime; time++) {\n            return_value = Math.max(return_value, this.speed(time))\n        }\n        return return_value\n    }\n\n    static newLinearFromEndTime(entity, destination, startTime, endTime) {\n        const p0 = [...entity.position(startTime)]\n        const p1 = [...destination.position(endTime)]\n        return new this(startTime, endTime, p0, p1)\n    }\n\n    static newQuadraticFromEndTime(entity, destination, startTime, endTime) {\n        const p0 = entity.position(startTime)\n        const p2 = destination.position(endTime)\n        const initialV = [...entity.velocity]\n        // const p1 = \n    }\n\n\n}\n\nexport default Bezier"]},"metadata":{},"sourceType":"module"}