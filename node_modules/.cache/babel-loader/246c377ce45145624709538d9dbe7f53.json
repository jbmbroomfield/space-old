{"ast":null,"code":"import Path from './Path';\n\nclass Orbit extends Path {\n  constructor(primary, radius, initialAngle, rotation = 0, direction = 1) {\n    super();\n    this.primary = primary;\n    this.radius = radius;\n    [this.minorRadius, this.majorRadius] = Array.isArray(radius) ? radius.sort() : [radius, radius];\n    const gravitationalConstant = primary.system.gravitationalConstant;\n    this.period = 2 * Math.PI * (this.majorRadius ** 3 / primary.mass / gravitationalConstant) ** 0.5;\n    this.initialAngle = initialAngle * Math.PI / 180;\n    this.rotation = rotation * Math.PI / 180;\n    this.direction = direction;\n  }\n\n  position(time) {\n    const [minorRadius, majorRadius] = Array.isArray(this.radius) ? this.radius.sort() : [this.radius, this.radius];\n    const [centreX, centreY] = this.getCentre(majorRadius, minorRadius, time);\n    const angle = 2 * Math.PI * this.direction / this.period * steps + this.initialAngle;\n    const [cosAngle, sinAngle] = [Math.cos(angle), Math.sin(angle)];\n    const [cosRotation, sinRotation] = [Math.cos(this.rotation), Math.sin(this.rotation)];\n    const x = majorRadius * cosAngle * cosRotation - minorRadius * sinAngle * sinRotation + centreX;\n    const y = majorRadius * cosAngle * sinRotation + minorRadius * sinAngle * cosRotation + centreY; // const x = majorRadius * Math.cos(angle) + centreX\n    // const y = minorRadius * Math.sin(angle) + centreY\n\n    return [x, y];\n  } // unrotated_position(steps) {\n  //     const [radiusX, radiusY] = Array.isArray(this.radius) ? this.radius : [this.radius, this.radius];\n  //     const [centreX, centreY] = this.getCentre(radiusX, radiusY)\n  //     const angle = this.direction * 2 * Math.PI / this.period * steps + this.initial * Math.PI / 180\n  //     const x = centreX + radiusX * Math.cos(angle)\n  //     const y = centreY + radiusY * Math.sin(angle)\n  //     return [x, y]\n  // }\n\n\n  getCentre(majorRadius, minorRadius, time) {\n    const [primaryX, primaryY] = Array.isArray(this.primary) ? this.primary : this.primary.position(time);\n    const distanceToCentre = (majorRadius ** 2 - minorRadius ** 2) ** 0.5;\n    const centreX = primaryX + distanceToCentre * Math.cos(this.rotation);\n    const centreY = primaryY + distanceToCentre * Math.sin(this.rotation);\n    return [centreX, centreY];\n  }\n\n}\n\nexport default Orbit;","map":{"version":3,"sources":["/home/jim/projects/space/src/classes/Orbit.js"],"names":["Path","Orbit","constructor","primary","radius","initialAngle","rotation","direction","minorRadius","majorRadius","Array","isArray","sort","gravitationalConstant","system","period","Math","PI","mass","position","time","centreX","centreY","getCentre","angle","steps","cosAngle","sinAngle","cos","sin","cosRotation","sinRotation","x","y","primaryX","primaryY","distanceToCentre"],"mappings":"AAAA,OAAOA,IAAP,MAAiB,QAAjB;;AAEA,MAAMC,KAAN,SAAoBD,IAApB,CAAyB;AACrBE,EAAAA,WAAW,CAACC,OAAD,EAAUC,MAAV,EAAkBC,YAAlB,EAAgCC,QAAQ,GAAG,CAA3C,EAA8CC,SAAS,GAAG,CAA1D,EAA6D;AACpE;AACA,SAAKJ,OAAL,GAAeA,OAAf;AACA,SAAKC,MAAL,GAAcA,MAAd;AACA,KAAC,KAAKI,WAAN,EAAmB,KAAKC,WAAxB,IAAuCC,KAAK,CAACC,OAAN,CAAcP,MAAd,IAAwBA,MAAM,CAACQ,IAAP,EAAxB,GAAwC,CAACR,MAAD,EAASA,MAAT,CAA/E;AAEA,UAAMS,qBAAqB,GAAGV,OAAO,CAACW,MAAR,CAAeD,qBAA7C;AAEA,SAAKE,MAAL,GAAc,IAAIC,IAAI,CAACC,EAAT,GAAc,CAAC,KAAKR,WAAL,IAAoB,CAApB,GAAwBN,OAAO,CAACe,IAAhC,GAAuCL,qBAAxC,KAAkE,GAA9F;AACA,SAAKR,YAAL,GAAoBA,YAAY,GAAGW,IAAI,CAACC,EAApB,GAAyB,GAA7C;AACA,SAAKX,QAAL,GAAgBA,QAAQ,GAAGU,IAAI,CAACC,EAAhB,GAAqB,GAArC;AACA,SAAKV,SAAL,GAAiBA,SAAjB;AACH;;AAEDY,EAAAA,QAAQ,CAACC,IAAD,EAAO;AACX,UAAM,CAACZ,WAAD,EAAcC,WAAd,IAA6BC,KAAK,CAACC,OAAN,CAAc,KAAKP,MAAnB,IAA6B,KAAKA,MAAL,CAAYQ,IAAZ,EAA7B,GAAkD,CAAC,KAAKR,MAAN,EAAc,KAAKA,MAAnB,CAArF;AACA,UAAM,CAACiB,OAAD,EAAUC,OAAV,IAAqB,KAAKC,SAAL,CAAed,WAAf,EAA4BD,WAA5B,EAAyCY,IAAzC,CAA3B;AACA,UAAMI,KAAK,GAAG,IAAIR,IAAI,CAACC,EAAT,GAAc,KAAKV,SAAnB,GAA+B,KAAKQ,MAApC,GAA6CU,KAA7C,GAAqD,KAAKpB,YAAxE;AACA,UAAM,CAACqB,QAAD,EAAWC,QAAX,IAAuB,CAACX,IAAI,CAACY,GAAL,CAASJ,KAAT,CAAD,EAAkBR,IAAI,CAACa,GAAL,CAASL,KAAT,CAAlB,CAA7B;AACA,UAAM,CAACM,WAAD,EAAcC,WAAd,IAA6B,CAACf,IAAI,CAACY,GAAL,CAAS,KAAKtB,QAAd,CAAD,EAA0BU,IAAI,CAACa,GAAL,CAAS,KAAKvB,QAAd,CAA1B,CAAnC;AACA,UAAM0B,CAAC,GAAGvB,WAAW,GAAGiB,QAAd,GAAyBI,WAAzB,GAAuCtB,WAAW,GAAGmB,QAAd,GAAyBI,WAAhE,GAA8EV,OAAxF;AACA,UAAMY,CAAC,GAAGxB,WAAW,GAAGiB,QAAd,GAAyBK,WAAzB,GAAuCvB,WAAW,GAAGmB,QAAd,GAAyBG,WAAhE,GAA8ER,OAAxF,CAPW,CASX;AACA;;AAEA,WAAO,CAACU,CAAD,EAAIC,CAAJ,CAAP;AACH,GA5BoB,CA8BrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEAV,EAAAA,SAAS,CAACd,WAAD,EAAcD,WAAd,EAA2BY,IAA3B,EAAiC;AACtC,UAAM,CAACc,QAAD,EAAWC,QAAX,IAAuBzB,KAAK,CAACC,OAAN,CAAc,KAAKR,OAAnB,IAA8B,KAAKA,OAAnC,GAA6C,KAAKA,OAAL,CAAagB,QAAb,CAAsBC,IAAtB,CAA1E;AACA,UAAMgB,gBAAgB,GAAG,CAAC3B,WAAW,IAAI,CAAf,GAAmBD,WAAW,IAAI,CAAnC,KAAyC,GAAlE;AACA,UAAMa,OAAO,GAAGa,QAAQ,GAAGE,gBAAgB,GAAGpB,IAAI,CAACY,GAAL,CAAS,KAAKtB,QAAd,CAA9C;AACA,UAAMgB,OAAO,GAAGa,QAAQ,GAAGC,gBAAgB,GAAGpB,IAAI,CAACa,GAAL,CAAS,KAAKvB,QAAd,CAA9C;AACA,WAAO,CAACe,OAAD,EAAUC,OAAV,CAAP;AAGH;;AA/CoB;;AAkDzB,eAAerB,KAAf","sourcesContent":["import Path from './Path'\n\nclass Orbit extends Path {\n    constructor(primary, radius, initialAngle, rotation = 0, direction = 1) {\n        super()\n        this.primary = primary;\n        this.radius = radius;\n        [this.minorRadius, this.majorRadius] = Array.isArray(radius) ? radius.sort() : [radius, radius]\n\n        const gravitationalConstant = primary.system.gravitationalConstant\n\n        this.period = 2 * Math.PI * (this.majorRadius ** 3 / primary.mass / gravitationalConstant) ** 0.5\n        this.initialAngle = initialAngle * Math.PI / 180\n        this.rotation = rotation * Math.PI / 180\n        this.direction = direction\n    }\n\n    position(time) {\n        const [minorRadius, majorRadius] = Array.isArray(this.radius) ? this.radius.sort() : [this.radius, this.radius];\n        const [centreX, centreY] = this.getCentre(majorRadius, minorRadius, time)\n        const angle = 2 * Math.PI * this.direction / this.period * steps + this.initialAngle;\n        const [cosAngle, sinAngle] = [Math.cos(angle), Math.sin(angle)];\n        const [cosRotation, sinRotation] = [Math.cos(this.rotation), Math.sin(this.rotation)]\n        const x = majorRadius * cosAngle * cosRotation - minorRadius * sinAngle * sinRotation + centreX\n        const y = majorRadius * cosAngle * sinRotation + minorRadius * sinAngle * cosRotation + centreY\n\n        // const x = majorRadius * Math.cos(angle) + centreX\n        // const y = minorRadius * Math.sin(angle) + centreY\n\n        return [x, y]\n    }\n\n    // unrotated_position(steps) {\n    //     const [radiusX, radiusY] = Array.isArray(this.radius) ? this.radius : [this.radius, this.radius];\n    //     const [centreX, centreY] = this.getCentre(radiusX, radiusY)\n    //     const angle = this.direction * 2 * Math.PI / this.period * steps + this.initial * Math.PI / 180\n    //     const x = centreX + radiusX * Math.cos(angle)\n    //     const y = centreY + radiusY * Math.sin(angle)\n    //     return [x, y]\n    // }\n\n    getCentre(majorRadius, minorRadius, time) {\n        const [primaryX, primaryY] = Array.isArray(this.primary) ? this.primary : this.primary.position(time);\n        const distanceToCentre = (majorRadius ** 2 - minorRadius ** 2) ** 0.5\n        const centreX = primaryX + distanceToCentre * Math.cos(this.rotation)\n        const centreY = primaryY + distanceToCentre * Math.sin(this.rotation)\n        return [centreX, centreY]\n\n\n    }\n}\n\nexport default Orbit"]},"metadata":{},"sourceType":"module"}