{"ast":null,"code":"class Orbit {\n  constructor(primary, radius, period, initialAngle, rotation = 0, direction = 1) {\n    this.primary = primary;\n    this.radius = radius;\n    this.period = period;\n    this.initialAngle = initialAngle;\n    this.rotation = rotation * Math.PI / 180;\n    this.direction = direction;\n  }\n\n  position(steps) {\n    const [minorRadius, majorRadius] = Array.isArray(this.radius) ? this.radius.sort() : [this.radius, this.radius];\n    const [centreX, centreY] = this.getCentre(majorRadius, minorRadius);\n    const angle = Math.PI * (this.direction * 2 / this.period * steps + this.initialAngle / 180);\n    const [cosAngle, sinAngle] = [Math.cos(angle), Math.sin(angle)];\n    const [cosRotation, sinRotation] = [Math.cos(this.rotation), Math.sin(this.rotation)];\n    const term1 = majorRadius * cosAngle * cosRotation;\n    const term2 = minorRadius * sinAngle * sinRotation;\n    const x = term1 - term2 + centreX;\n    const y = term1 + term2 + centreY;\n    return [x, y];\n  } // unrotated_position(steps) {\n  //     const [radiusX, radiusY] = Array.isArray(this.radius) ? this.radius : [this.radius, this.radius];\n  //     const [centreX, centreY] = this.getCentre(radiusX, radiusY)\n  //     const angle = this.direction * 2 * Math.PI / this.period * steps + this.initial * Math.PI / 180\n  //     const x = centreX + radiusX * Math.cos(angle)\n  //     const y = centreY + radiusY * Math.sin(angle)\n  //     return [x, y]\n  // }\n\n\n  getCentre(majorRadius, minorRadius) {\n    const [primaryX, primaryY] = Array.isArray(this.primary) ? this.primary : this.primary.position;\n    return [primaryX, primaryY];\n    return [primaryX + (majorRadius ** 2 - minorRadius ** 2) ** 0.5, primaryY];\n  }\n\n}\n\nexport default Orbit;","map":{"version":3,"sources":["/home/jim/projects/space/src/classes/Orbit.js"],"names":["Orbit","constructor","primary","radius","period","initialAngle","rotation","direction","Math","PI","position","steps","minorRadius","majorRadius","Array","isArray","sort","centreX","centreY","getCentre","angle","cosAngle","sinAngle","cos","sin","cosRotation","sinRotation","term1","term2","x","y","primaryX","primaryY"],"mappings":"AAAA,MAAMA,KAAN,CAAY;AACRC,EAAAA,WAAW,CAACC,OAAD,EAAUC,MAAV,EAAkBC,MAAlB,EAA0BC,YAA1B,EAAwCC,QAAQ,GAAG,CAAnD,EAAsDC,SAAS,GAAG,CAAlE,EAAqE;AAC5E,SAAKL,OAAL,GAAeA,OAAf;AACA,SAAKC,MAAL,GAAcA,MAAd;AACA,SAAKC,MAAL,GAAcA,MAAd;AACA,SAAKC,YAAL,GAAoBA,YAApB;AACA,SAAKC,QAAL,GAAgBA,QAAQ,GAAGE,IAAI,CAACC,EAAhB,GAAqB,GAArC;AACA,SAAKF,SAAL,GAAiBA,SAAjB;AACH;;AAEDG,EAAAA,QAAQ,CAACC,KAAD,EAAQ;AACZ,UAAM,CAACC,WAAD,EAAcC,WAAd,IAA6BC,KAAK,CAACC,OAAN,CAAc,KAAKZ,MAAnB,IAA6B,KAAKA,MAAL,CAAYa,IAAZ,EAA7B,GAAkD,CAAC,KAAKb,MAAN,EAAc,KAAKA,MAAnB,CAArF;AACA,UAAM,CAACc,OAAD,EAAUC,OAAV,IAAqB,KAAKC,SAAL,CAAeN,WAAf,EAA4BD,WAA5B,CAA3B;AACA,UAAMQ,KAAK,GAAGZ,IAAI,CAACC,EAAL,IAAW,KAAKF,SAAL,GAAiB,CAAjB,GAAqB,KAAKH,MAA1B,GAAmCO,KAAnC,GAA2C,KAAKN,YAAL,GAAoB,GAA1E,CAAd;AACA,UAAM,CAACgB,QAAD,EAAWC,QAAX,IAAuB,CAACd,IAAI,CAACe,GAAL,CAASH,KAAT,CAAD,EAAkBZ,IAAI,CAACgB,GAAL,CAASJ,KAAT,CAAlB,CAA7B;AACA,UAAM,CAACK,WAAD,EAAcC,WAAd,IAA6B,CAAClB,IAAI,CAACe,GAAL,CAAS,KAAKjB,QAAd,CAAD,EAA0BE,IAAI,CAACgB,GAAL,CAAS,KAAKlB,QAAd,CAA1B,CAAnC;AACA,UAAMqB,KAAK,GAAGd,WAAW,GAAGQ,QAAd,GAAyBI,WAAvC;AACA,UAAMG,KAAK,GAAGhB,WAAW,GAAGU,QAAd,GAAyBI,WAAvC;AACA,UAAMG,CAAC,GAAGF,KAAK,GAAGC,KAAR,GAAgBX,OAA1B;AACA,UAAMa,CAAC,GAAGH,KAAK,GAAGC,KAAR,GAAgBV,OAA1B;AACA,WAAO,CAACW,CAAD,EAAIC,CAAJ,CAAP;AACH,GArBO,CAuBR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEAX,EAAAA,SAAS,CAACN,WAAD,EAAcD,WAAd,EAA2B;AAChC,UAAM,CAACmB,QAAD,EAAWC,QAAX,IAAuBlB,KAAK,CAACC,OAAN,CAAc,KAAKb,OAAnB,IAA8B,KAAKA,OAAnC,GAA6C,KAAKA,OAAL,CAAaQ,QAAvF;AACA,WAAO,CAACqB,QAAD,EAAWC,QAAX,CAAP;AACA,WAAO,CAACD,QAAQ,GAAG,CAAClB,WAAW,IAAI,CAAf,GAAmBD,WAAW,IAAI,CAAnC,KAAyC,GAArD,EAA0DoB,QAA1D,CAAP;AACH;;AApCO;;AAuCZ,eAAehC,KAAf","sourcesContent":["class Orbit {\n    constructor(primary, radius, period, initialAngle, rotation = 0, direction = 1) {\n        this.primary = primary\n        this.radius = radius\n        this.period = period\n        this.initialAngle = initialAngle\n        this.rotation = rotation * Math.PI / 180\n        this.direction = direction\n    }\n\n    position(steps) {\n        const [minorRadius, majorRadius] = Array.isArray(this.radius) ? this.radius.sort() : [this.radius, this.radius];\n        const [centreX, centreY] = this.getCentre(majorRadius, minorRadius)\n        const angle = Math.PI * (this.direction * 2 / this.period * steps + this.initialAngle / 180);\n        const [cosAngle, sinAngle] = [Math.cos(angle), Math.sin(angle)];\n        const [cosRotation, sinRotation] = [Math.cos(this.rotation), Math.sin(this.rotation)]\n        const term1 = majorRadius * cosAngle * cosRotation\n        const term2 = minorRadius * sinAngle * sinRotation\n        const x = term1 - term2 + centreX\n        const y = term1 + term2 + centreY\n        return [x, y]\n    }\n\n    // unrotated_position(steps) {\n    //     const [radiusX, radiusY] = Array.isArray(this.radius) ? this.radius : [this.radius, this.radius];\n    //     const [centreX, centreY] = this.getCentre(radiusX, radiusY)\n    //     const angle = this.direction * 2 * Math.PI / this.period * steps + this.initial * Math.PI / 180\n    //     const x = centreX + radiusX * Math.cos(angle)\n    //     const y = centreY + radiusY * Math.sin(angle)\n    //     return [x, y]\n    // }\n\n    getCentre(majorRadius, minorRadius) {\n        const [primaryX, primaryY] = Array.isArray(this.primary) ? this.primary : this.primary.position;\n        return [primaryX, primaryY]\n        return [primaryX + (majorRadius ** 2 - minorRadius ** 2) ** 0.5, primaryY]\n    }\n}\n\nexport default Orbit"]},"metadata":{},"sourceType":"module"}